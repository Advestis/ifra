<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ifra.datapreps API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ifra.datapreps</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from bisect import bisect
from typing import Tuple, Union, List, Optional
from transparentpath import TransparentPath

import numpy as np
import pandas as pd

from .configs import NodeDataConfig
from .loader import load_y
import logging
logger = logging.getLogger(__name__)


class DataPrep:
    &#34;&#34;&#34;Abstract class for DataPrep.&#34;&#34;&#34;

    def __init__(self, data: NodeDataConfig, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        data: NodeDataConfig
            `ifra.node.Node`&#39;s *data*
        kwargs:
            Any additionnal keyword argument that the overleading class accepts. Those arguments will become attributes.
        &#34;&#34;&#34;
        self.data = data
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

    def dataprep(self):
        &#34;&#34;&#34;Writes the output of the dataprep in `ifra.node.Node`&#39;s *data.x_path* and `ifra.node.Node`&#39;s *data.y_path*
        parent directories by appending *_datapreped* to the files names. Modifies `ifra.node.Node`&#39;s
        *data.x_datapreped_path* and `ifra.node.Node`&#39;s *data.y_datapreped_path* to point to those files.
        &#34;&#34;&#34;
        x, y = self.dataprep_method(
            self.data.x_path.read(**self.data.x_read_kwargs),
            load_y(self.data.y_path, **self.data.y_read_kwargs)
        )
        x_suffix = self.data.x_path.suffix
        y_suffix = self.data.y_path.suffix
        self.data.x_datapreped_path = self.data.x_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(x_suffix)
        self.data.y_datapreped_path = self.data.y_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(y_suffix)

        self.data.x_datapreped_path.write(x)
        self.data.y_datapreped_path.write(y)

    def dataprep_method(self, x: pd.DataFrame, y: pd.Series) -&gt; Tuple[pd.DataFrame, pd.Series]:
        &#34;&#34;&#34;To be implemented in daughter class.

        Returns
        -------
        Tuple[pd.DataFrame, pd.DataFrame]
            Datapreped x and y
        &#34;&#34;&#34;
        pass


class BinFeaturesDataPrep(DataPrep):
    &#34;&#34;&#34;Overloads DataPrep class. Bins each feature columns in &#39;nbins&#39; modalities. Does not modify y.

    Can be used by giving *binfeatures* as *dataprep* configuration when creating a `ifra.node.Node`

    Attributes
    ----------
    nbins: int
        Number of bins to use
    &#34;&#34;&#34;

    def __init__(self, data: NodeDataConfig, nbins: int, bins: dict, save_bins: Optional[TransparentPath]):
        if save_bins is not None:
            save_bins = TransparentPath(save_bins)
        super().__init__(data, nbins=nbins, bins=bins, save_bins=save_bins)

    def dataprep_method(self, x, y):

        # noinspection PyUnresolvedReferences
        def to_apply(xx: pd.Series):
            if xx.name in self.bins:
                bins = self.bins[xx.name]
            else:
                bins = get_bins(xx, self.nbins)
                self.bins[xx.name] = bins

            to_ret = discretize(xx, bins)

            if self.save_bins is not None:
                if not self.save_bins.isfile():
                    self.save_bins.write({xx.name: bins})
                else:
                    allbins = self.save_bins.read()
                    allbins[xx.name] = bins
                    self.save_bins.write(allbins)
            return to_ret

        def find_bins(xx: pd.Series, nbins: int) -&gt; np.ndarray:
            &#34;&#34;&#34;
            Function used to find the bins to discretize xcol in nbins modalities

            Parameters
            ----------
            xx : pd.Series
               Series to discretize

            nbins: int
                number of modalities

            Return
            ------
            bins: np.ndarray
               the bins for disretization (result from numpy percentile function)
            &#34;&#34;&#34;
            q_list = np.arange(100.0 / nbins, 100.0, 100.0 / nbins)
            bins = np.array([np.nanpercentile(xx, i) for i in q_list])
            return bins

        def get_bins(xx: pd.Series, nb_bucket: int) -&gt; np.ndarray:
            logger.debug(f&#34;Getting bins for {xx.name}...&#34;)
            if nb_bucket == 0:
                raise ValueError(&#34;nb_bucket must be greater than 0&#34;)
            if nb_bucket == 1:
                return np.array([])
            if len(xx) == 0 or len(xx) == 1:
                return np.array([])
            if len(np.unique(xx)) &lt;= nb_bucket:
                return np.ediff1d(np.unique(xx)) / 2. + np.unique(xx)[:-1]
            bins = find_bins(xx, nb_bucket)
            while len(set(bins.round(5))) != len(bins):
                nb_bucket -= 1
                bins = find_bins(xx, nb_bucket)
            if len(bins) != nb_bucket - 1:
                raise ValueError(f&#34;Error in get_bins : {len(bins) + 1} bins where found but {nb_bucket} were asked.&#34;)
            logger.debug(f&#34;... got bins for {xx.name}&#34;)
            return bins

        def discretize(xx: pd.Series, bins: Union[np.ndarray, List[float]]) -&gt; pd.Series:
            &#34;&#34;&#34;
            Transform a Series of float to a Series if int, where each float is replaced by the bin it matches.

            Parameters
            ----------
            xx : pd.Series
                Series to discretize
            bins : Union[np.ndarray, List[float]]
                The list of bins in the form e.g. [0.1, 0.3, ... 0.8] :
                    // -inf ---&gt; 0.1 is bin 0
                    // 0.1 ---&gt; 0.3 is bin 1, etc.
                    // 0.8 ---&gt; +inf is the last bin

            Return
            ------
            discrete_x : pd.Series
                The discretization of x

            &#34;&#34;&#34;
            logger.debug(f&#34;Discretizing {xx.name}...&#34;)
            mask = np.isnan(xx)
            discrete_x = xx.apply(lambda var: bisect(bins, var))
            discrete_x[mask] = np.nan
            logger.debug(f&#34;... discretized {xx.name}&#34;)
            return discrete_x

        # noinspection PyUnresolvedReferences
        x = x.apply(lambda xx: to_apply(xx), axis=0)
        return x, y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ifra.datapreps.BinFeaturesDataPrep"><code class="flex name class">
<span>class <span class="ident">BinFeaturesDataPrep</span></span>
<span>(</span><span>data: <a title="ifra.configs.NodeDataConfig" href="configs.html#ifra.configs.NodeDataConfig">NodeDataConfig</a>, nbins: int, bins: dict, save_bins: Optional[transparentpath.gcsutils.transparentpath.TransparentPath])</span>
</code></dt>
<dd>
<div class="desc"><p>Overloads DataPrep class. Bins each feature columns in 'nbins' modalities. Does not modify y.</p>
<p>Can be used by giving <em>binfeatures</em> as <em>dataprep</em> configuration when creating a <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code></p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nbins</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bins to use</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>NodeDataConfig</code></dt>
<dd><code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s <em>data</em></dd>
</dl>
<p>kwargs:
Any additionnal keyword argument that the overleading class accepts. Those arguments will become attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinFeaturesDataPrep(DataPrep):
    &#34;&#34;&#34;Overloads DataPrep class. Bins each feature columns in &#39;nbins&#39; modalities. Does not modify y.

    Can be used by giving *binfeatures* as *dataprep* configuration when creating a `ifra.node.Node`

    Attributes
    ----------
    nbins: int
        Number of bins to use
    &#34;&#34;&#34;

    def __init__(self, data: NodeDataConfig, nbins: int, bins: dict, save_bins: Optional[TransparentPath]):
        if save_bins is not None:
            save_bins = TransparentPath(save_bins)
        super().__init__(data, nbins=nbins, bins=bins, save_bins=save_bins)

    def dataprep_method(self, x, y):

        # noinspection PyUnresolvedReferences
        def to_apply(xx: pd.Series):
            if xx.name in self.bins:
                bins = self.bins[xx.name]
            else:
                bins = get_bins(xx, self.nbins)
                self.bins[xx.name] = bins

            to_ret = discretize(xx, bins)

            if self.save_bins is not None:
                if not self.save_bins.isfile():
                    self.save_bins.write({xx.name: bins})
                else:
                    allbins = self.save_bins.read()
                    allbins[xx.name] = bins
                    self.save_bins.write(allbins)
            return to_ret

        def find_bins(xx: pd.Series, nbins: int) -&gt; np.ndarray:
            &#34;&#34;&#34;
            Function used to find the bins to discretize xcol in nbins modalities

            Parameters
            ----------
            xx : pd.Series
               Series to discretize

            nbins: int
                number of modalities

            Return
            ------
            bins: np.ndarray
               the bins for disretization (result from numpy percentile function)
            &#34;&#34;&#34;
            q_list = np.arange(100.0 / nbins, 100.0, 100.0 / nbins)
            bins = np.array([np.nanpercentile(xx, i) for i in q_list])
            return bins

        def get_bins(xx: pd.Series, nb_bucket: int) -&gt; np.ndarray:
            logger.debug(f&#34;Getting bins for {xx.name}...&#34;)
            if nb_bucket == 0:
                raise ValueError(&#34;nb_bucket must be greater than 0&#34;)
            if nb_bucket == 1:
                return np.array([])
            if len(xx) == 0 or len(xx) == 1:
                return np.array([])
            if len(np.unique(xx)) &lt;= nb_bucket:
                return np.ediff1d(np.unique(xx)) / 2. + np.unique(xx)[:-1]
            bins = find_bins(xx, nb_bucket)
            while len(set(bins.round(5))) != len(bins):
                nb_bucket -= 1
                bins = find_bins(xx, nb_bucket)
            if len(bins) != nb_bucket - 1:
                raise ValueError(f&#34;Error in get_bins : {len(bins) + 1} bins where found but {nb_bucket} were asked.&#34;)
            logger.debug(f&#34;... got bins for {xx.name}&#34;)
            return bins

        def discretize(xx: pd.Series, bins: Union[np.ndarray, List[float]]) -&gt; pd.Series:
            &#34;&#34;&#34;
            Transform a Series of float to a Series if int, where each float is replaced by the bin it matches.

            Parameters
            ----------
            xx : pd.Series
                Series to discretize
            bins : Union[np.ndarray, List[float]]
                The list of bins in the form e.g. [0.1, 0.3, ... 0.8] :
                    // -inf ---&gt; 0.1 is bin 0
                    // 0.1 ---&gt; 0.3 is bin 1, etc.
                    // 0.8 ---&gt; +inf is the last bin

            Return
            ------
            discrete_x : pd.Series
                The discretization of x

            &#34;&#34;&#34;
            logger.debug(f&#34;Discretizing {xx.name}...&#34;)
            mask = np.isnan(xx)
            discrete_x = xx.apply(lambda var: bisect(bins, var))
            discrete_x[mask] = np.nan
            logger.debug(f&#34;... discretized {xx.name}&#34;)
            return discrete_x

        # noinspection PyUnresolvedReferences
        x = x.apply(lambda xx: to_apply(xx), axis=0)
        return x, y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifra.datapreps.DataPrep" href="#ifra.datapreps.DataPrep">DataPrep</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifra.datapreps.DataPrep" href="#ifra.datapreps.DataPrep">DataPrep</a></b></code>:
<ul class="hlist">
<li><code><a title="ifra.datapreps.DataPrep.dataprep" href="#ifra.datapreps.DataPrep.dataprep">dataprep</a></code></li>
<li><code><a title="ifra.datapreps.DataPrep.dataprep_method" href="#ifra.datapreps.DataPrep.dataprep_method">dataprep_method</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifra.datapreps.DataPrep"><code class="flex name class">
<span>class <span class="ident">DataPrep</span></span>
<span>(</span><span>data: <a title="ifra.configs.NodeDataConfig" href="configs.html#ifra.configs.NodeDataConfig">NodeDataConfig</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for DataPrep.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>NodeDataConfig</code></dt>
<dd><code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s <em>data</em></dd>
</dl>
<p>kwargs:
Any additionnal keyword argument that the overleading class accepts. Those arguments will become attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPrep:
    &#34;&#34;&#34;Abstract class for DataPrep.&#34;&#34;&#34;

    def __init__(self, data: NodeDataConfig, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        data: NodeDataConfig
            `ifra.node.Node`&#39;s *data*
        kwargs:
            Any additionnal keyword argument that the overleading class accepts. Those arguments will become attributes.
        &#34;&#34;&#34;
        self.data = data
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

    def dataprep(self):
        &#34;&#34;&#34;Writes the output of the dataprep in `ifra.node.Node`&#39;s *data.x_path* and `ifra.node.Node`&#39;s *data.y_path*
        parent directories by appending *_datapreped* to the files names. Modifies `ifra.node.Node`&#39;s
        *data.x_datapreped_path* and `ifra.node.Node`&#39;s *data.y_datapreped_path* to point to those files.
        &#34;&#34;&#34;
        x, y = self.dataprep_method(
            self.data.x_path.read(**self.data.x_read_kwargs),
            load_y(self.data.y_path, **self.data.y_read_kwargs)
        )
        x_suffix = self.data.x_path.suffix
        y_suffix = self.data.y_path.suffix
        self.data.x_datapreped_path = self.data.x_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(x_suffix)
        self.data.y_datapreped_path = self.data.y_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(y_suffix)

        self.data.x_datapreped_path.write(x)
        self.data.y_datapreped_path.write(y)

    def dataprep_method(self, x: pd.DataFrame, y: pd.Series) -&gt; Tuple[pd.DataFrame, pd.Series]:
        &#34;&#34;&#34;To be implemented in daughter class.

        Returns
        -------
        Tuple[pd.DataFrame, pd.DataFrame]
            Datapreped x and y
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ifra.datapreps.BinFeaturesDataPrep" href="#ifra.datapreps.BinFeaturesDataPrep">BinFeaturesDataPrep</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifra.datapreps.DataPrep.dataprep"><code class="name flex">
<span>def <span class="ident">dataprep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the output of the dataprep in <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s <em>data.x_path</em> and <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s <em>data.y_path</em>
parent directories by appending <em>_datapreped</em> to the files names. Modifies <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s
<em>data.x_datapreped_path</em> and <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code>'s <em>data.y_datapreped_path</em> to point to those files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataprep(self):
    &#34;&#34;&#34;Writes the output of the dataprep in `ifra.node.Node`&#39;s *data.x_path* and `ifra.node.Node`&#39;s *data.y_path*
    parent directories by appending *_datapreped* to the files names. Modifies `ifra.node.Node`&#39;s
    *data.x_datapreped_path* and `ifra.node.Node`&#39;s *data.y_datapreped_path* to point to those files.
    &#34;&#34;&#34;
    x, y = self.dataprep_method(
        self.data.x_path.read(**self.data.x_read_kwargs),
        load_y(self.data.y_path, **self.data.y_read_kwargs)
    )
    x_suffix = self.data.x_path.suffix
    y_suffix = self.data.y_path.suffix
    self.data.x_datapreped_path = self.data.x_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(x_suffix)
    self.data.y_datapreped_path = self.data.y_path.with_suffix(&#34;&#34;).append(&#34;_datapreped&#34;).with_suffix(y_suffix)

    self.data.x_datapreped_path.write(x)
    self.data.y_datapreped_path.write(y)</code></pre>
</details>
</dd>
<dt id="ifra.datapreps.DataPrep.dataprep_method"><code class="name flex">
<span>def <span class="ident">dataprep_method</span></span>(<span>self, x: pandas.core.frame.DataFrame, y: pandas.core.series.Series) ‑> Tuple[pandas.core.frame.DataFrame, pandas.core.series.Series]</span>
</code></dt>
<dd>
<div class="desc"><p>To be implemented in daughter class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[pd.DataFrame, pd.DataFrame]</code></dt>
<dd>Datapreped x and y</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataprep_method(self, x: pd.DataFrame, y: pd.Series) -&gt; Tuple[pd.DataFrame, pd.Series]:
    &#34;&#34;&#34;To be implemented in daughter class.

    Returns
    -------
    Tuple[pd.DataFrame, pd.DataFrame]
        Datapreped x and y
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ifra" href="index.html">ifra</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ifra.datapreps.BinFeaturesDataPrep" href="#ifra.datapreps.BinFeaturesDataPrep">BinFeaturesDataPrep</a></code></h4>
</li>
<li>
<h4><code><a title="ifra.datapreps.DataPrep" href="#ifra.datapreps.DataPrep">DataPrep</a></code></h4>
<ul class="">
<li><code><a title="ifra.datapreps.DataPrep.dataprep" href="#ifra.datapreps.DataPrep.dataprep">dataprep</a></code></li>
<li><code><a title="ifra.datapreps.DataPrep.dataprep_method" href="#ifra.datapreps.DataPrep.dataprep_method">dataprep_method</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>