<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ifra.aggregator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ifra.aggregator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import datetime
from time import time, sleep
from typing import List, Union, Tuple

from ruleskit import RuleSet
from tablewriter import TableWriter
from transparentpath import TransparentPath
import logging

from .configs import AggregatorConfig
from .actor import Actor
from .decorator import emit
from .aggregations import AdaBoostAggregation, Aggregation, ReverseAdaBoostAggregation, AggregateAll

logger = logging.getLogger(__name__)


class NodeGate:

    &#34;&#34;&#34;This class is the gate used by the aggregator to interact with the remote nodes.
    It only knows the path to the main model of a given node, and nothing else, thus making each node an anonymous
    contributor to the model.
    It implements a method, `ifra.aggregator.NodeGate.interact`, that checks whether the node produced a new model.

    Attributes
    ----------
    ok: bool
        True if the object initiated correctly
    model_path: TransparentPath
        The file containing one node model
    id: int
        Unique NodeGate id number, corresponding to the number of existing NodeGate at object creation.
    model: RuleSet
        Latest node model, same as `ifra.node.Node` *model*. None at initialisation, set by
        `ifra.aggregator.NodeGate.interact`
    last_fetch: datetime
        Last time the node produced a new model. None at initialisation, set by
        `ifra.aggregator.NodeGate.interact`
    &#34;&#34;&#34;

    instances = 0
    &#34;&#34;&#34;Counts the number of existing objects&#34;&#34;&#34;

    paths = []
    &#34;&#34;&#34;Remembers all paths known by all instances of the class. This is done to avoid creating several nodes with the
    same model path.&#34;&#34;&#34;

    def __init__(self, model_main_path: TransparentPath):
        &#34;&#34;&#34;
        Parameters
        ----------
        model_main_path: TransparentPath
            Path to the node&#39;s model file.
        &#34;&#34;&#34;

        if model_main_path in self.paths:
            raise ValueError(f&#34;You can not recreate already existing node with model path {model_main_path}&#34;)
        self.ok = False
        self.model_path = model_main_path
        self.id = self.instances
        self.__class__.instances += 1
        self.paths.append(model_main_path)

        self.model = None
        self.last_fetch = None
        self.id_set = False
        self.ok = True
        self.reference_node_config = None

    def interact(self) -&gt; bool:
        &#34;&#34;&#34;Fetch one anonymous node&#39;s latest model.

        Returns
        -------
        True if successfully fetched new model, else False. Can be False if the model&#39;s file disappeared, or if has not
        been modified since last check, or if it contains no rules.
        &#34;&#34;&#34;

        def get_model() -&gt; bool:
            &#34;&#34;&#34;Fetch the node&#39;s model.
            `ifra.aggregator.NodeGate` *last_fetch* will be set to now.
            &#34;&#34;&#34;
            self.model = RuleSet()
            self.model.load(self.model_path)
            self.last_fetch = datetime.now()
            if len(self.model) == 0:
                logger.info(
                    f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch},&#34;
                    f&#34; but it was empty. Ignoring it.&#34;
                )
                return False
            self.new_model_found = True
            logger.info(f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch}&#34;)
            return True

        if self.model is None:
            # The node has not produced any model yet if self.model is None. No need to bother with self.last_fetch
            # then, just get the model.
            if self.model_path.is_file():
                return get_model()
            else:
                logger.warning(f&#34;Aggregator - model located at {self.model_path} disapeared.&#34;)
                return False
        else:
            # The node has already produced a model. So we only get its model if it is new. We know that by
            # checking the modification time of the node&#39;s model file.
            if self.model_path.is_file():
                if self.model_path.info()[&#34;mtime&#34;] &gt; self.last_fetch.timestamp():
                    return get_model()
                else:
                    logger.debug(f&#34;Aggregator - Node {self.id} has no new model. Skipping for now.&#34;)
                    return False
            else:
                logger.warning(f&#34;Aggregator - Model located at {self.model_path} disapeared.&#34;)
                return False


class Aggregator(Actor):
    &#34;&#34;&#34;Implementation of the notion of aggregator in federated learning.

    It monitors changes in a given remote GCP directory, were nodes are expected to write their models.
    It periodically checks for new or modified model files that is downloads. When enough model files are downloaded,
    the aggregator aggregates them to produce the aggregated model, which is saved to a directory.
    This directory is then read by the central server to update the central model
    (see `ifra.central_server.CentralServer`).
    &#34;Enough&#34; model is defined in the aggregator configuration (see `ifra.configs.AggregatorConfig`)

    Attributes
    ----------
    aggregator_configs: AggregatorConfig
        see `ifra.configs.AggregatorConfig`
    nodes: List[NodeGate]
        List of all gates to the nodes the aggregator found.
    model: RuleSet
        Aggregated model
    aggregation: Aggregation
        Instance of one of the `ifra.aggregations.Aggregation` daughter classes.
    &#34;&#34;&#34;

    possible_aggregations = {
        &#34;adaboost&#34;: AdaBoostAggregation, &#34;reverseadaboost&#34;: ReverseAdaBoostAggregation, &#34;keepall&#34;: AggregateAll
    }
    &#34;&#34;&#34;Possible string values and corresponding aggregation methods for *aggregation* attribute of
    `ifra.aggregator.Aggregator`&#34;&#34;&#34;

    def __init__(
        self,
        aggregator_configs: AggregatorConfig,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        aggregator_configs: AggregatorConfig
            Aggregator configuration. See `ifra.configs.AggregatorConfig`
        &#34;&#34;&#34;
        self.aggregator_configs = None
        self.nodes = []
        self.model = None
        self.aggregation = None
        super().__init__(aggregator_configs=aggregator_configs)

    @emit
    def create(self):

        self.nodes = []

        if self.aggregator_configs.min_number_of_new_models &lt; 1:
            raise ValueError(&#34;Minimum number of new nodes to trigger aggregation must be 1 or more&#34;)

        self.model = None

        if self.aggregator_configs.aggregation not in self.possible_aggregations:
            function = self.aggregator_configs.aggregation.split(&#34;.&#34;)[-1]
            module = self.aggregator_configs.aggregation.replace(f&#34;.{function}&#34;, &#34;&#34;)
            self.aggregation = getattr(__import__(module, globals(), locals(), [function], 0), function)(self)
            if not isinstance(self.aggregation, Aggregation):
                raise TypeError(&#34;Aggregator aggregation should inherite from Aggregation class&#34;)
        else:
            self.aggregation = self.possible_aggregations[self.aggregator_configs.aggregation](self)

    @emit
    def aggregate(self, models: List[RuleSet]) -&gt; Tuple[str, Union[RuleSet, None]]:
        &#34;&#34;&#34;Aggregates models in `ifra.aggregator.Aggregator` *model* using
        `ifra.aggregator.Aggregator` *aggregation*

        Parameters
        ----------
        models: List[RuleSet]
            New models provided by the nodes.

        Returns
        -------
        Tuple[str, Union[RuleSet, None]]
            First item of the tuple can be :
              * &#34;updated&#34; if aggregated model was updated
              * &#34;pass&#34; if no new rules were found
            The second item is the aggregated model if the first item is &#34;updated&#34;, None otherwise
        &#34;&#34;&#34;
        return self.aggregation.aggregate(models)

    @emit
    def model_to_file(self) -&gt; None:
        &#34;&#34;&#34;Saves `ifra.node.Node` *model* to `ifra.configs.AggregatorConfig` *aggregated_model_path*,
        overwritting any existing file here, and in another file in the same directory but with a unique name.
        Will also produce a .pdf of the model using TableWriter.
        Does not do anything if `ifra.node.Node` *model* is None
        &#34;&#34;&#34;
        model = self.model
        # Aggregated model&#39;s criterion and coverage are meaningless
        model._coverage = None
        model.criterion = None

        iteration = 0
        name = self.aggregator_configs.aggregated_model_path.stem
        path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;
        while path.is_file():
            iteration += 1
            path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;

        path = path.with_suffix(&#34;.csv&#34;)
        if not path.parent.isdir():
            path.parent.mkdir(parents=True)
        model.save(path)
        model.save(self.aggregator_configs.aggregated_model_path)
        logger.info(f&#34;Aggregator - Saved aggregated model in &#39;{self.aggregator_configs.aggregated_model_path}&#39;&#34;)

        try:
            path_table = path.with_suffix(&#34;.pdf&#34;)
            TableWriter(
                path_table, path.read(index_col=0).apply(lambda x: x.round(3) if x.dtype == float else x), paperwidth=30
            ).compile(clean_tex=True)
        except ValueError:
            logger.warning(&#34;Aggregator - Failed to produce tablewriter. Is LaTeX installed ?&#34;)

    @emit
    def run(self, timeout: Union[int, float] = 0, sleeptime: Union[int, float] = 5):
        &#34;&#34;&#34;Monitors new changes in the nodes, every &#39;&#39;sleeptime&#39;&#39; seconds for &#39;&#39;timeout&#39;&#39; seconds, triggering
        aggregation and pushing aggregated model to nodes when enough new node models are available.

        Stops if all nodes gave a model but no new rules could be found from them. Tells the nodes to stop too.

        Parameters
        ----------
        timeout: Union[int, float]
            How many seconds should the run last. If &lt;= 0, will last until killed by the user. Default value = 0.
        sleeptime: Union[int, float]
            How many seconds between each checks for new nodes models. Default value = 5.
        &#34;&#34;&#34;
        updated_nodes = []

        if timeout &lt;= 0:
            logger.warning(
                &#34;Aggregator - You did not specify a timeout for your run. It will last until manually stopped.&#34;
            )
        logger.info(
            &#34;Starting aggregator. Monitoring changes in nodes&#39; models directories&#34;
            f&#34; {self.aggregator_configs.node_models_path}.&#34;
        )
        started = self.iterations != 0  # To force at least one loop of the while to trigger

        t = time()
        while time() - t &lt; timeout or timeout &lt;= 0 or started is False:
            started = True
            new_models = False
            new_nodes = 0
            if not self.aggregator_configs.node_models_path.isdir():
                self.aggregator_configs.node_models_path.mkdir(parents=True)
            for path in self.aggregator_configs.node_models_path.glob(&#34;model_main_*.csv&#34;):
                if path in NodeGate.paths:
                    # Already found this node in a previous check
                    continue
                node = NodeGate(path)
                if node.ok:
                    self.nodes.append(node)
                    new_nodes += 1
                else:
                    logger.warning(&#34;Aggregator - One node could not be instantiated. Ignoring it.&#34;)

            if new_nodes &gt; 0:
                logger.info(f&#34;Aggregator - Found {new_nodes} new nodes. Aggregator now knows {len(self.nodes)} nodes.&#34;)

            for node in self.nodes:
                # Node fetches its latest model from GCP. Returns True if a new model was found and it has rules.
                if node.interact() is False:
                    continue

                if node not in updated_nodes:
                    updated_nodes.append(node)
                if len(updated_nodes) &gt;= self.aggregator_configs.min_number_of_new_models:
                    new_models = True

            if new_models:
                logger.info(f&#34;Aggregator - Found enough ({len(updated_nodes)}) new nodes models.&#34;)
                what_now = self.aggregate([node.model for node in set(updated_nodes)])
                if what_now == &#34;updated&#34;:
                    # Aggregation successfully updated aggregated model: clean the list of updated nodes.
                    updated_nodes = []

                    if self.model is None:
                        raise ValueError(&#34;Should never happen !&#34;)
                    self.iterations += 1
                    self.model_to_file()
                else:
                    logger.info(&#34;Aggregator - New models did not produce anything new yet.&#34;)

            sleep(sleeptime)

        logger.info(f&#34;Aggregator - Timeout of {timeout} seconds reached, stopping aggregator.&#34;)
        if self.model is None:
            logger.warning(&#34;Learning failed to produce an aggregatored model. No output generated.&#34;)
        logger.info(f&#34;Aggregator - Made {self.iterations} complete iterations between aggregator and nodes.&#34;)
        logger.info(f&#34;Aggregator - Results saved in {self.aggregator_configs.aggregated_model_path}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ifra.aggregator.Aggregator"><code class="flex name class">
<span>class <span class="ident">Aggregator</span></span>
<span>(</span><span>aggregator_configs: <a title="ifra.configs.AggregatorConfig" href="configs.html#ifra.configs.AggregatorConfig">AggregatorConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the notion of aggregator in federated learning.</p>
<p>It monitors changes in a given remote GCP directory, were nodes are expected to write their models.
It periodically checks for new or modified model files that is downloads. When enough model files are downloaded,
the aggregator aggregates them to produce the aggregated model, which is saved to a directory.
This directory is then read by the central server to update the central model
(see <code><a title="ifra.central_server.CentralServer" href="central_server.html#ifra.central_server.CentralServer">CentralServer</a></code>).
"Enough" model is defined in the aggregator configuration (see <code><a title="ifra.configs.AggregatorConfig" href="configs.html#ifra.configs.AggregatorConfig">AggregatorConfig</a></code>)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>aggregator_configs</code></strong> :&ensp;<code>AggregatorConfig</code></dt>
<dd>see <code><a title="ifra.configs.AggregatorConfig" href="configs.html#ifra.configs.AggregatorConfig">AggregatorConfig</a></code></dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>List[<a title="ifra.aggregator.NodeGate" href="#ifra.aggregator.NodeGate">NodeGate</a>]</code></dt>
<dd>List of all gates to the nodes the aggregator found.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>RuleSet</code></dt>
<dd>Aggregated model</dd>
<dt><strong><code>aggregation</code></strong> :&ensp;<code>Aggregation</code></dt>
<dd>Instance of one of the <code><a title="ifra.aggregations.Aggregation" href="aggregations.html#ifra.aggregations.Aggregation">Aggregation</a></code> daughter classes.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aggregator_configs</code></strong> :&ensp;<code>AggregatorConfig</code></dt>
<dd>Aggregator configuration. See <code><a title="ifra.configs.AggregatorConfig" href="configs.html#ifra.configs.AggregatorConfig">AggregatorConfig</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aggregator(Actor):
    &#34;&#34;&#34;Implementation of the notion of aggregator in federated learning.

    It monitors changes in a given remote GCP directory, were nodes are expected to write their models.
    It periodically checks for new or modified model files that is downloads. When enough model files are downloaded,
    the aggregator aggregates them to produce the aggregated model, which is saved to a directory.
    This directory is then read by the central server to update the central model
    (see `ifra.central_server.CentralServer`).
    &#34;Enough&#34; model is defined in the aggregator configuration (see `ifra.configs.AggregatorConfig`)

    Attributes
    ----------
    aggregator_configs: AggregatorConfig
        see `ifra.configs.AggregatorConfig`
    nodes: List[NodeGate]
        List of all gates to the nodes the aggregator found.
    model: RuleSet
        Aggregated model
    aggregation: Aggregation
        Instance of one of the `ifra.aggregations.Aggregation` daughter classes.
    &#34;&#34;&#34;

    possible_aggregations = {
        &#34;adaboost&#34;: AdaBoostAggregation, &#34;reverseadaboost&#34;: ReverseAdaBoostAggregation, &#34;keepall&#34;: AggregateAll
    }
    &#34;&#34;&#34;Possible string values and corresponding aggregation methods for *aggregation* attribute of
    `ifra.aggregator.Aggregator`&#34;&#34;&#34;

    def __init__(
        self,
        aggregator_configs: AggregatorConfig,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        aggregator_configs: AggregatorConfig
            Aggregator configuration. See `ifra.configs.AggregatorConfig`
        &#34;&#34;&#34;
        self.aggregator_configs = None
        self.nodes = []
        self.model = None
        self.aggregation = None
        super().__init__(aggregator_configs=aggregator_configs)

    @emit
    def create(self):

        self.nodes = []

        if self.aggregator_configs.min_number_of_new_models &lt; 1:
            raise ValueError(&#34;Minimum number of new nodes to trigger aggregation must be 1 or more&#34;)

        self.model = None

        if self.aggregator_configs.aggregation not in self.possible_aggregations:
            function = self.aggregator_configs.aggregation.split(&#34;.&#34;)[-1]
            module = self.aggregator_configs.aggregation.replace(f&#34;.{function}&#34;, &#34;&#34;)
            self.aggregation = getattr(__import__(module, globals(), locals(), [function], 0), function)(self)
            if not isinstance(self.aggregation, Aggregation):
                raise TypeError(&#34;Aggregator aggregation should inherite from Aggregation class&#34;)
        else:
            self.aggregation = self.possible_aggregations[self.aggregator_configs.aggregation](self)

    @emit
    def aggregate(self, models: List[RuleSet]) -&gt; Tuple[str, Union[RuleSet, None]]:
        &#34;&#34;&#34;Aggregates models in `ifra.aggregator.Aggregator` *model* using
        `ifra.aggregator.Aggregator` *aggregation*

        Parameters
        ----------
        models: List[RuleSet]
            New models provided by the nodes.

        Returns
        -------
        Tuple[str, Union[RuleSet, None]]
            First item of the tuple can be :
              * &#34;updated&#34; if aggregated model was updated
              * &#34;pass&#34; if no new rules were found
            The second item is the aggregated model if the first item is &#34;updated&#34;, None otherwise
        &#34;&#34;&#34;
        return self.aggregation.aggregate(models)

    @emit
    def model_to_file(self) -&gt; None:
        &#34;&#34;&#34;Saves `ifra.node.Node` *model* to `ifra.configs.AggregatorConfig` *aggregated_model_path*,
        overwritting any existing file here, and in another file in the same directory but with a unique name.
        Will also produce a .pdf of the model using TableWriter.
        Does not do anything if `ifra.node.Node` *model* is None
        &#34;&#34;&#34;
        model = self.model
        # Aggregated model&#39;s criterion and coverage are meaningless
        model._coverage = None
        model.criterion = None

        iteration = 0
        name = self.aggregator_configs.aggregated_model_path.stem
        path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;
        while path.is_file():
            iteration += 1
            path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;

        path = path.with_suffix(&#34;.csv&#34;)
        if not path.parent.isdir():
            path.parent.mkdir(parents=True)
        model.save(path)
        model.save(self.aggregator_configs.aggregated_model_path)
        logger.info(f&#34;Aggregator - Saved aggregated model in &#39;{self.aggregator_configs.aggregated_model_path}&#39;&#34;)

        try:
            path_table = path.with_suffix(&#34;.pdf&#34;)
            TableWriter(
                path_table, path.read(index_col=0).apply(lambda x: x.round(3) if x.dtype == float else x), paperwidth=30
            ).compile(clean_tex=True)
        except ValueError:
            logger.warning(&#34;Aggregator - Failed to produce tablewriter. Is LaTeX installed ?&#34;)

    @emit
    def run(self, timeout: Union[int, float] = 0, sleeptime: Union[int, float] = 5):
        &#34;&#34;&#34;Monitors new changes in the nodes, every &#39;&#39;sleeptime&#39;&#39; seconds for &#39;&#39;timeout&#39;&#39; seconds, triggering
        aggregation and pushing aggregated model to nodes when enough new node models are available.

        Stops if all nodes gave a model but no new rules could be found from them. Tells the nodes to stop too.

        Parameters
        ----------
        timeout: Union[int, float]
            How many seconds should the run last. If &lt;= 0, will last until killed by the user. Default value = 0.
        sleeptime: Union[int, float]
            How many seconds between each checks for new nodes models. Default value = 5.
        &#34;&#34;&#34;
        updated_nodes = []

        if timeout &lt;= 0:
            logger.warning(
                &#34;Aggregator - You did not specify a timeout for your run. It will last until manually stopped.&#34;
            )
        logger.info(
            &#34;Starting aggregator. Monitoring changes in nodes&#39; models directories&#34;
            f&#34; {self.aggregator_configs.node_models_path}.&#34;
        )
        started = self.iterations != 0  # To force at least one loop of the while to trigger

        t = time()
        while time() - t &lt; timeout or timeout &lt;= 0 or started is False:
            started = True
            new_models = False
            new_nodes = 0
            if not self.aggregator_configs.node_models_path.isdir():
                self.aggregator_configs.node_models_path.mkdir(parents=True)
            for path in self.aggregator_configs.node_models_path.glob(&#34;model_main_*.csv&#34;):
                if path in NodeGate.paths:
                    # Already found this node in a previous check
                    continue
                node = NodeGate(path)
                if node.ok:
                    self.nodes.append(node)
                    new_nodes += 1
                else:
                    logger.warning(&#34;Aggregator - One node could not be instantiated. Ignoring it.&#34;)

            if new_nodes &gt; 0:
                logger.info(f&#34;Aggregator - Found {new_nodes} new nodes. Aggregator now knows {len(self.nodes)} nodes.&#34;)

            for node in self.nodes:
                # Node fetches its latest model from GCP. Returns True if a new model was found and it has rules.
                if node.interact() is False:
                    continue

                if node not in updated_nodes:
                    updated_nodes.append(node)
                if len(updated_nodes) &gt;= self.aggregator_configs.min_number_of_new_models:
                    new_models = True

            if new_models:
                logger.info(f&#34;Aggregator - Found enough ({len(updated_nodes)}) new nodes models.&#34;)
                what_now = self.aggregate([node.model for node in set(updated_nodes)])
                if what_now == &#34;updated&#34;:
                    # Aggregation successfully updated aggregated model: clean the list of updated nodes.
                    updated_nodes = []

                    if self.model is None:
                        raise ValueError(&#34;Should never happen !&#34;)
                    self.iterations += 1
                    self.model_to_file()
                else:
                    logger.info(&#34;Aggregator - New models did not produce anything new yet.&#34;)

            sleep(sleeptime)

        logger.info(f&#34;Aggregator - Timeout of {timeout} seconds reached, stopping aggregator.&#34;)
        if self.model is None:
            logger.warning(&#34;Learning failed to produce an aggregatored model. No output generated.&#34;)
        logger.info(f&#34;Aggregator - Made {self.iterations} complete iterations between aggregator and nodes.&#34;)
        logger.info(f&#34;Aggregator - Results saved in {self.aggregator_configs.aggregated_model_path}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifra.actor.Actor" href="actor.html#ifra.actor.Actor">Actor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ifra.aggregator.Aggregator.possible_aggregations"><code class="name">var <span class="ident">possible_aggregations</span></code></dt>
<dd>
<div class="desc"><p>Possible string values and corresponding aggregation methods for <em>aggregation</em> attribute of
<code><a title="ifra.aggregator.Aggregator" href="#ifra.aggregator.Aggregator">Aggregator</a></code></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ifra.aggregator.Aggregator.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>self, models: List[ruleskit.ruleset.RuleSet]) ‑> Tuple[str, Optional[ruleskit.ruleset.RuleSet]]</span>
</code></dt>
<dd>
<div class="desc"><p>Aggregates models in <code><a title="ifra.aggregator.Aggregator" href="#ifra.aggregator.Aggregator">Aggregator</a></code> <em>model</em> using
<code><a title="ifra.aggregator.Aggregator" href="#ifra.aggregator.Aggregator">Aggregator</a></code> <em>aggregation</em></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>models</code></strong> :&ensp;<code>List[RuleSet]</code></dt>
<dd>New models provided by the nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[str, Union[RuleSet, None]]</code></dt>
<dd>First item of the tuple can be :
* "updated" if aggregated model was updated
* "pass" if no new rules were found
The second item is the aggregated model if the first item is "updated", None otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@emit
def aggregate(self, models: List[RuleSet]) -&gt; Tuple[str, Union[RuleSet, None]]:
    &#34;&#34;&#34;Aggregates models in `ifra.aggregator.Aggregator` *model* using
    `ifra.aggregator.Aggregator` *aggregation*

    Parameters
    ----------
    models: List[RuleSet]
        New models provided by the nodes.

    Returns
    -------
    Tuple[str, Union[RuleSet, None]]
        First item of the tuple can be :
          * &#34;updated&#34; if aggregated model was updated
          * &#34;pass&#34; if no new rules were found
        The second item is the aggregated model if the first item is &#34;updated&#34;, None otherwise
    &#34;&#34;&#34;
    return self.aggregation.aggregate(models)</code></pre>
</details>
</dd>
<dt id="ifra.aggregator.Aggregator.model_to_file"><code class="name flex">
<span>def <span class="ident">model_to_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code> <em>model</em> to <code><a title="ifra.configs.AggregatorConfig" href="configs.html#ifra.configs.AggregatorConfig">AggregatorConfig</a></code> <em>aggregated_model_path</em>,
overwritting any existing file here, and in another file in the same directory but with a unique name.
Will also produce a .pdf of the model using TableWriter.
Does not do anything if <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code> <em>model</em> is None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@emit
def model_to_file(self) -&gt; None:
    &#34;&#34;&#34;Saves `ifra.node.Node` *model* to `ifra.configs.AggregatorConfig` *aggregated_model_path*,
    overwritting any existing file here, and in another file in the same directory but with a unique name.
    Will also produce a .pdf of the model using TableWriter.
    Does not do anything if `ifra.node.Node` *model* is None
    &#34;&#34;&#34;
    model = self.model
    # Aggregated model&#39;s criterion and coverage are meaningless
    model._coverage = None
    model.criterion = None

    iteration = 0
    name = self.aggregator_configs.aggregated_model_path.stem
    path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;
    while path.is_file():
        iteration += 1
        path = self.aggregator_configs.aggregated_model_path.parent / f&#34;{name}_{iteration}.csv&#34;

    path = path.with_suffix(&#34;.csv&#34;)
    if not path.parent.isdir():
        path.parent.mkdir(parents=True)
    model.save(path)
    model.save(self.aggregator_configs.aggregated_model_path)
    logger.info(f&#34;Aggregator - Saved aggregated model in &#39;{self.aggregator_configs.aggregated_model_path}&#39;&#34;)

    try:
        path_table = path.with_suffix(&#34;.pdf&#34;)
        TableWriter(
            path_table, path.read(index_col=0).apply(lambda x: x.round(3) if x.dtype == float else x), paperwidth=30
        ).compile(clean_tex=True)
    except ValueError:
        logger.warning(&#34;Aggregator - Failed to produce tablewriter. Is LaTeX installed ?&#34;)</code></pre>
</details>
</dd>
<dt id="ifra.aggregator.Aggregator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, timeout: Union[int, float] = 0, sleeptime: Union[int, float] = 5)</span>
</code></dt>
<dd>
<div class="desc"><p>Monitors new changes in the nodes, every ''sleeptime'' seconds for ''timeout'' seconds, triggering
aggregation and pushing aggregated model to nodes when enough new node models are available.</p>
<p>Stops if all nodes gave a model but no new rules could be found from them. Tells the nodes to stop too.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>How many seconds should the run last. If &lt;= 0, will last until killed by the user. Default value = 0.</dd>
<dt><strong><code>sleeptime</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>How many seconds between each checks for new nodes models. Default value = 5.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@emit
def run(self, timeout: Union[int, float] = 0, sleeptime: Union[int, float] = 5):
    &#34;&#34;&#34;Monitors new changes in the nodes, every &#39;&#39;sleeptime&#39;&#39; seconds for &#39;&#39;timeout&#39;&#39; seconds, triggering
    aggregation and pushing aggregated model to nodes when enough new node models are available.

    Stops if all nodes gave a model but no new rules could be found from them. Tells the nodes to stop too.

    Parameters
    ----------
    timeout: Union[int, float]
        How many seconds should the run last. If &lt;= 0, will last until killed by the user. Default value = 0.
    sleeptime: Union[int, float]
        How many seconds between each checks for new nodes models. Default value = 5.
    &#34;&#34;&#34;
    updated_nodes = []

    if timeout &lt;= 0:
        logger.warning(
            &#34;Aggregator - You did not specify a timeout for your run. It will last until manually stopped.&#34;
        )
    logger.info(
        &#34;Starting aggregator. Monitoring changes in nodes&#39; models directories&#34;
        f&#34; {self.aggregator_configs.node_models_path}.&#34;
    )
    started = self.iterations != 0  # To force at least one loop of the while to trigger

    t = time()
    while time() - t &lt; timeout or timeout &lt;= 0 or started is False:
        started = True
        new_models = False
        new_nodes = 0
        if not self.aggregator_configs.node_models_path.isdir():
            self.aggregator_configs.node_models_path.mkdir(parents=True)
        for path in self.aggregator_configs.node_models_path.glob(&#34;model_main_*.csv&#34;):
            if path in NodeGate.paths:
                # Already found this node in a previous check
                continue
            node = NodeGate(path)
            if node.ok:
                self.nodes.append(node)
                new_nodes += 1
            else:
                logger.warning(&#34;Aggregator - One node could not be instantiated. Ignoring it.&#34;)

        if new_nodes &gt; 0:
            logger.info(f&#34;Aggregator - Found {new_nodes} new nodes. Aggregator now knows {len(self.nodes)} nodes.&#34;)

        for node in self.nodes:
            # Node fetches its latest model from GCP. Returns True if a new model was found and it has rules.
            if node.interact() is False:
                continue

            if node not in updated_nodes:
                updated_nodes.append(node)
            if len(updated_nodes) &gt;= self.aggregator_configs.min_number_of_new_models:
                new_models = True

        if new_models:
            logger.info(f&#34;Aggregator - Found enough ({len(updated_nodes)}) new nodes models.&#34;)
            what_now = self.aggregate([node.model for node in set(updated_nodes)])
            if what_now == &#34;updated&#34;:
                # Aggregation successfully updated aggregated model: clean the list of updated nodes.
                updated_nodes = []

                if self.model is None:
                    raise ValueError(&#34;Should never happen !&#34;)
                self.iterations += 1
                self.model_to_file()
            else:
                logger.info(&#34;Aggregator - New models did not produce anything new yet.&#34;)

        sleep(sleeptime)

    logger.info(f&#34;Aggregator - Timeout of {timeout} seconds reached, stopping aggregator.&#34;)
    if self.model is None:
        logger.warning(&#34;Learning failed to produce an aggregatored model. No output generated.&#34;)
    logger.info(f&#34;Aggregator - Made {self.iterations} complete iterations between aggregator and nodes.&#34;)
    logger.info(f&#34;Aggregator - Results saved in {self.aggregator_configs.aggregated_model_path}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifra.actor.Actor" href="actor.html#ifra.actor.Actor">Actor</a></b></code>:
<ul class="hlist">
<li><code><a title="ifra.actor.Actor.create" href="actor.html#ifra.actor.Actor.create">create</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifra.aggregator.NodeGate"><code class="flex name class">
<span>class <span class="ident">NodeGate</span></span>
<span>(</span><span>model_main_path: transparentpath.gcsutils.transparentpath.TransparentPath)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the gate used by the aggregator to interact with the remote nodes.
It only knows the path to the main model of a given node, and nothing else, thus making each node an anonymous
contributor to the model.
It implements a method, <code><a title="ifra.aggregator.NodeGate.interact" href="#ifra.aggregator.NodeGate.interact">NodeGate.interact()</a></code>, that checks whether the node produced a new model.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ok</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the object initiated correctly</dd>
<dt><strong><code>model_path</code></strong> :&ensp;<code>TransparentPath</code></dt>
<dd>The file containing one node model</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique NodeGate id number, corresponding to the number of existing NodeGate at object creation.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>RuleSet</code></dt>
<dd>Latest node model, same as <code><a title="ifra.node.Node" href="node.html#ifra.node.Node">Node</a></code> <em>model</em>. None at initialisation, set by
<code><a title="ifra.aggregator.NodeGate.interact" href="#ifra.aggregator.NodeGate.interact">NodeGate.interact()</a></code></dd>
<dt><strong><code>last_fetch</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Last time the node produced a new model. None at initialisation, set by
<code><a title="ifra.aggregator.NodeGate.interact" href="#ifra.aggregator.NodeGate.interact">NodeGate.interact()</a></code></dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_main_path</code></strong> :&ensp;<code>TransparentPath</code></dt>
<dd>Path to the node's model file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeGate:

    &#34;&#34;&#34;This class is the gate used by the aggregator to interact with the remote nodes.
    It only knows the path to the main model of a given node, and nothing else, thus making each node an anonymous
    contributor to the model.
    It implements a method, `ifra.aggregator.NodeGate.interact`, that checks whether the node produced a new model.

    Attributes
    ----------
    ok: bool
        True if the object initiated correctly
    model_path: TransparentPath
        The file containing one node model
    id: int
        Unique NodeGate id number, corresponding to the number of existing NodeGate at object creation.
    model: RuleSet
        Latest node model, same as `ifra.node.Node` *model*. None at initialisation, set by
        `ifra.aggregator.NodeGate.interact`
    last_fetch: datetime
        Last time the node produced a new model. None at initialisation, set by
        `ifra.aggregator.NodeGate.interact`
    &#34;&#34;&#34;

    instances = 0
    &#34;&#34;&#34;Counts the number of existing objects&#34;&#34;&#34;

    paths = []
    &#34;&#34;&#34;Remembers all paths known by all instances of the class. This is done to avoid creating several nodes with the
    same model path.&#34;&#34;&#34;

    def __init__(self, model_main_path: TransparentPath):
        &#34;&#34;&#34;
        Parameters
        ----------
        model_main_path: TransparentPath
            Path to the node&#39;s model file.
        &#34;&#34;&#34;

        if model_main_path in self.paths:
            raise ValueError(f&#34;You can not recreate already existing node with model path {model_main_path}&#34;)
        self.ok = False
        self.model_path = model_main_path
        self.id = self.instances
        self.__class__.instances += 1
        self.paths.append(model_main_path)

        self.model = None
        self.last_fetch = None
        self.id_set = False
        self.ok = True
        self.reference_node_config = None

    def interact(self) -&gt; bool:
        &#34;&#34;&#34;Fetch one anonymous node&#39;s latest model.

        Returns
        -------
        True if successfully fetched new model, else False. Can be False if the model&#39;s file disappeared, or if has not
        been modified since last check, or if it contains no rules.
        &#34;&#34;&#34;

        def get_model() -&gt; bool:
            &#34;&#34;&#34;Fetch the node&#39;s model.
            `ifra.aggregator.NodeGate` *last_fetch* will be set to now.
            &#34;&#34;&#34;
            self.model = RuleSet()
            self.model.load(self.model_path)
            self.last_fetch = datetime.now()
            if len(self.model) == 0:
                logger.info(
                    f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch},&#34;
                    f&#34; but it was empty. Ignoring it.&#34;
                )
                return False
            self.new_model_found = True
            logger.info(f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch}&#34;)
            return True

        if self.model is None:
            # The node has not produced any model yet if self.model is None. No need to bother with self.last_fetch
            # then, just get the model.
            if self.model_path.is_file():
                return get_model()
            else:
                logger.warning(f&#34;Aggregator - model located at {self.model_path} disapeared.&#34;)
                return False
        else:
            # The node has already produced a model. So we only get its model if it is new. We know that by
            # checking the modification time of the node&#39;s model file.
            if self.model_path.is_file():
                if self.model_path.info()[&#34;mtime&#34;] &gt; self.last_fetch.timestamp():
                    return get_model()
                else:
                    logger.debug(f&#34;Aggregator - Node {self.id} has no new model. Skipping for now.&#34;)
                    return False
            else:
                logger.warning(f&#34;Aggregator - Model located at {self.model_path} disapeared.&#34;)
                return False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ifra.aggregator.NodeGate.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"><p>Counts the number of existing objects</p></div>
</dd>
<dt id="ifra.aggregator.NodeGate.paths"><code class="name">var <span class="ident">paths</span></code></dt>
<dd>
<div class="desc"><p>Remembers all paths known by all instances of the class. This is done to avoid creating several nodes with the
same model path.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ifra.aggregator.NodeGate.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch one anonymous node's latest model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if successfully fetched new model, else False. Can be False if the model's file disappeared,</code> or <code>if has not</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>been modified since last check, or if it contains no rules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interact(self) -&gt; bool:
    &#34;&#34;&#34;Fetch one anonymous node&#39;s latest model.

    Returns
    -------
    True if successfully fetched new model, else False. Can be False if the model&#39;s file disappeared, or if has not
    been modified since last check, or if it contains no rules.
    &#34;&#34;&#34;

    def get_model() -&gt; bool:
        &#34;&#34;&#34;Fetch the node&#39;s model.
        `ifra.aggregator.NodeGate` *last_fetch* will be set to now.
        &#34;&#34;&#34;
        self.model = RuleSet()
        self.model.load(self.model_path)
        self.last_fetch = datetime.now()
        if len(self.model) == 0:
            logger.info(
                f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch},&#34;
                f&#34; but it was empty. Ignoring it.&#34;
            )
            return False
        self.new_model_found = True
        logger.info(f&#34;Aggregator - Fetched new model from node {self.id} at {self.last_fetch}&#34;)
        return True

    if self.model is None:
        # The node has not produced any model yet if self.model is None. No need to bother with self.last_fetch
        # then, just get the model.
        if self.model_path.is_file():
            return get_model()
        else:
            logger.warning(f&#34;Aggregator - model located at {self.model_path} disapeared.&#34;)
            return False
    else:
        # The node has already produced a model. So we only get its model if it is new. We know that by
        # checking the modification time of the node&#39;s model file.
        if self.model_path.is_file():
            if self.model_path.info()[&#34;mtime&#34;] &gt; self.last_fetch.timestamp():
                return get_model()
            else:
                logger.debug(f&#34;Aggregator - Node {self.id} has no new model. Skipping for now.&#34;)
                return False
        else:
            logger.warning(f&#34;Aggregator - Model located at {self.model_path} disapeared.&#34;)
            return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ifra" href="index.html">ifra</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ifra.aggregator.Aggregator" href="#ifra.aggregator.Aggregator">Aggregator</a></code></h4>
<ul class="">
<li><code><a title="ifra.aggregator.Aggregator.aggregate" href="#ifra.aggregator.Aggregator.aggregate">aggregate</a></code></li>
<li><code><a title="ifra.aggregator.Aggregator.model_to_file" href="#ifra.aggregator.Aggregator.model_to_file">model_to_file</a></code></li>
<li><code><a title="ifra.aggregator.Aggregator.possible_aggregations" href="#ifra.aggregator.Aggregator.possible_aggregations">possible_aggregations</a></code></li>
<li><code><a title="ifra.aggregator.Aggregator.run" href="#ifra.aggregator.Aggregator.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifra.aggregator.NodeGate" href="#ifra.aggregator.NodeGate">NodeGate</a></code></h4>
<ul class="">
<li><code><a title="ifra.aggregator.NodeGate.instances" href="#ifra.aggregator.NodeGate.instances">instances</a></code></li>
<li><code><a title="ifra.aggregator.NodeGate.interact" href="#ifra.aggregator.NodeGate.interact">interact</a></code></li>
<li><code><a title="ifra.aggregator.NodeGate.paths" href="#ifra.aggregator.NodeGate.paths">paths</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>